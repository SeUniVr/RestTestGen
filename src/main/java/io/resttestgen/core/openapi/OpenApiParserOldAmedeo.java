package io.resttestgen.core.openapi;

import com.google.gson.Gson;
import com.google.gson.internal.LinkedTreeMap;
import io.resttestgen.boot.ApiUnderTest;
import io.resttestgen.core.datatype.HttpMethod;
import io.resttestgen.core.datatype.parameter.attributes.ParameterType;
import io.resttestgen.core.helper.ObjectHelper;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jgrapht.alg.util.Pair;

import java.io.Reader;
import java.lang.reflect.InvocationTargetException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

public class OpenApiParserOldAmedeo {

    private static final Logger logger = LogManager.getLogger(OpenApiParserOldAmedeo.class);

    private static Map<String, Object> openApiMap; // Map parsed by GSON

    public static Map<String, Object> getOpenApiMap() {
        return openApiMap;
    }

    /**
     * The Main function of the class that is used to parse the given specification file.
     * This method resolves the '$ref' attributes within the specification, adds an extension field 'x-componentName' to
     * each resolved field and normalizes parameters defined at path level adding them to every path item.
     * As a result, an OpenApi object is instantiated.
     * @return An OpenApi object that contains the parsed structure of the parsed OpenAPI specification.
     * @throws InvalidOpenApiException if the provided specification is invalid. Reason will be reported in the message.
     */
    public static OpenApi parse(ApiUnderTest apiUnderTest) throws InvalidOpenApiException {

        Path specificationPath = Path.of(apiUnderTest.getComputedJsonSpecificationPath());

        if (!Files.exists(specificationPath)) {
            throw new InvalidOpenApiException("The OpenAPI specification file for the API cannot be found. Did you " +
                    "place the in the proper directory?");
        }

        Gson gson = new Gson();
        try {
            Reader reader = Files.newBufferedReader(specificationPath);
            openApiMap = gson.fromJson(reader, Map.class);
        } catch (Exception e) {
            logger.error(e);
            throw new InvalidOpenApiException("Error while parsing the OpenAPI specification as JSON. Please check " +
                    "that the provided specification is a valid JSON file.");
        }

        logger.debug("OpenAPI specification correctly loaded from file. Starting parsing.");

        // The specification is invalid in case it does not contain servers or path properties
        if (!openApiMap.containsKey("servers")) {
            throw new InvalidOpenApiException("Missing 'servers' field. This field is mandatory as is used as target " +
                    "for the requests generated by RestTestGen.");
        }
        if (!openApiMap.containsKey("paths")) {
            throw new InvalidOpenApiException("Missing 'paths' field. At least one path or operation in required in " +
                    "your API specification.");
        }

        /*
         * Add extension with schema names to enrich the specification and keep track of the specification fields
         * that have exactly the same schema
         */
        addSchemasNames();
        // Expand all the refs (replace refs with their actual schema)
        expandOpenApiRefs();
        // Normalize common parameters
        unfoldPathSharedParameters();
        // Infer parameter types where missing
        inferParameterTypes();
        // Normalize 'required' attribute in request/response bodies
        unfoldRequiredAttributes();

        // Start parsing specification fields
        OpenApi openApi = new OpenApi();

        // Read servers
        List<Map<String, Object>> servers = (List<Map<String, Object>>) openApiMap.get("servers");
        servers.forEach(server -> {
            try {
                openApi.addServer(new URL((String) server.get("url")));
            } catch (MalformedURLException|ClassCastException e) {
                logger.error(e);
            }
        });
        if (openApi.getServers().isEmpty()) {
            throw new InvalidOpenApiException("No valid server found within the OpenAPI specification.");
        }

        // Read paths and create operations
        Map<String, Object> paths = (Map<String, Object>) openApiMap.get("paths");

        // Fetch paths
        for (Map.Entry<String, Object> path : paths.entrySet()) {

            if (path.getKey().startsWith("x-")) {
                continue;
            }

            // Fetch operations
            for (Map.Entry<String, Object> operation : ((Map<String, Object>) path.getValue()).entrySet()) {

                if (!HttpMethod.isHttpMethod(operation.getKey())) {
                    continue;
                }

                Operation o = new Operation(path.getKey(),
                        HttpMethod.getMethod(operation.getKey()),
                        (Map<String, Object>) operation.getValue());
                o.setReadOnly();
                openApi.addOperation(o);
            }
        }

        // Finally, parse specification information
        Map<String, Object> infoMap = safeGet(openApiMap, "info", LinkedTreeMap.class);
        Map<String, Object> contactMap = safeGet(infoMap, "contact", LinkedTreeMap.class);
        Map<String, Object> licenseMap = safeGet(infoMap, "license", LinkedTreeMap.class);
        openApi.setTitle(safeGet(infoMap, "title", String.class));
        openApi.setSummary(safeGet(infoMap, "summary", String.class));
        openApi.setDescription(safeGet(infoMap, "description", String.class));
        openApi.setTermsOfService(safeGet(infoMap, "termsOfService", String.class));
        openApi.setContactName(safeGet(contactMap, "name", String.class));
        openApi.setContactUrl(safeGet(contactMap, "url", String.class));
        openApi.setContactEmail(safeGet(contactMap, "email", String.class));
        openApi.setLicenseName(safeGet(licenseMap, "name", String.class));
        openApi.setLicenseUrl(safeGet(licenseMap, "url", String.class));
        openApi.setVersion(safeGet(infoMap, "version", String.class));

        logger.info("OpenAPI specification correctly parsed.");
        return openApi;
    }



    public OpenApi parseOld() throws InvalidOpenApiException {

        // The specification is invalid in case it does not contain servers or path properties
        if (!this.openApiMap.containsKey("servers")) {
            throw new InvalidOpenApiException("Missing 'servers' field. This field is mandatory as is used as target " +
                    "for the requests generated by RestTestGen.");
        }
        if (!this.openApiMap.containsKey("paths")) {
            throw new InvalidOpenApiException("Missing 'paths' field. At least one path or operation in required in " +
                    "your API specification.");
        }

        /*
         * Add extension with schema names to enrich the specification and keep track of the specification fields
         * that have exactly the same schema
         */
        addSchemasNames();
        // Expand all the refs (replace refs with their actual schema)
        expandOpenApiRefs();
        // Normalize common parameters
        unfoldPathSharedParameters();
        // Infer parameter types where missing
        inferParameterTypes();
        // Normalize 'required' attribute in request/response bodies
        unfoldRequiredAttributes();

        // Start parsing specification fields
        OpenApi openApi = new OpenApi();

        // Read servers
        List<Map<String, Object>> servers = (List<Map<String, Object>>) this.openApiMap.get("servers");
        servers.forEach(server -> {
            try {
                openApi.addServer(new URL((String) server.get("url")));
            } catch (MalformedURLException|ClassCastException e) {
                logger.error(e);
            }
        });
        if (openApi.getServers().isEmpty()) {
            throw new InvalidOpenApiException("No valid server found within the OpenAPI specification.");
        }

        // Read paths and create operations
        Map<String, Object> paths = (Map<String, Object>) this.openApiMap.get("paths");

        // Fetch paths
        for (Map.Entry<String, Object> path : paths.entrySet()) {

            if (path.getKey().startsWith("x-")) {
                continue;
            }

            // Fetch operations
            for (Map.Entry<String, Object> operation : ((Map<String, Object>) path.getValue()).entrySet()) {

                if (!HttpMethod.isHttpMethod(operation.getKey())) {
                    continue;
                }

                Operation o = new Operation(path.getKey(),
                        HttpMethod.getMethod(operation.getKey()),
                        (Map<String, Object>) operation.getValue());
                o.setReadOnly();
                openApi.addOperation(o);
            }
        }

        // Finally, parse specification information
        Map<String, Object> infoMap = safeGet(this.openApiMap, "info", LinkedTreeMap.class);
        Map<String, Object> contactMap = safeGet(infoMap, "contact", LinkedTreeMap.class);
        Map<String, Object> licenseMap = safeGet(infoMap, "license", LinkedTreeMap.class);
        openApi.setTitle(safeGet(infoMap, "title", String.class));
        openApi.setSummary(safeGet(infoMap, "summary", String.class));
        openApi.setDescription(safeGet(infoMap, "description", String.class));
        openApi.setTermsOfService(safeGet(infoMap, "termsOfService", String.class));
        openApi.setContactName(safeGet(contactMap, "name", String.class));
        openApi.setContactUrl(safeGet(contactMap, "url", String.class));
        openApi.setContactEmail(safeGet(contactMap, "email", String.class));
        openApi.setLicenseName(safeGet(licenseMap, "name", String.class));
        openApi.setLicenseUrl(safeGet(licenseMap, "url", String.class));
        openApi.setVersion(safeGet(infoMap, "version", String.class));

        logger.info("OpenAPI specification correctly parsed.");
        return openApi;
    }

    /**
     * Function that infers types when missing. For every pathItem, parameter, request body and response are checked
     * for missing 'type' field
     */
    private static void inferParameterTypes() {
        logger.debug("Inferring parameter types where missing.");

        Map<String, Map<String, Map<String, Object>>> paths =
                (Map<String, Map<String, Map<String, Object>>>) openApiMap.get("paths");

        paths.values().forEach(
                operationMap -> operationMap.entrySet().stream().filter((entry -> HttpMethod.isHttpMethod(entry.getKey())))
                        .forEach(entry -> {

                            Map<String, Object> operation = entry.getValue();

                            // Infer types for parameters filed
                            safeGet(operation, "parameters", ArrayList.class).forEach(
                                    parameter -> recursiveTypeInference((Map<String, Object>) parameter)
                            );

                            Map<String, Object> requestBody = safeGet(operation, "requestBody", LinkedTreeMap.class);
                            Map<String, Object> content = safeGet(requestBody, "content", LinkedTreeMap.class);

                            // At the moment we only support JSON and x-www-form-urlencoded
                            Map<String, Object> jsonContent = safeGet(content, "application/json", LinkedTreeMap.class);

                            // In case no JSON content is provided, we try to use x-www-form-urlencoded content
                            if (jsonContent.isEmpty()) {
                                jsonContent = safeGet(content, "application/x-www-form-urlencoded", LinkedTreeMap.class);
                            }

                            if (jsonContent.isEmpty()) {
                                jsonContent = safeGet(content, "*/*", LinkedTreeMap.class);
                            }

                            Map<String, Object> schema = safeGet(jsonContent, "schema", LinkedTreeMap.class);
                            if (!schema.isEmpty()) {
                                recursiveTypeInference(schema);
                            }

                            Map<String, Object> responses = safeGet(operation, "responses", LinkedTreeMap.class);

                            for (Map.Entry<String, Object> responseMap : responses.entrySet()) {
                                Map<String, Object> response = (Map<String, Object>) responseMap.getValue();
                                content = safeGet(response, "content", LinkedTreeMap.class);

                                // At the moment we only support JSON and x-www-form-urlencoded
                                jsonContent = safeGet(content, "application/json", LinkedTreeMap.class);

                                // In case no JSON content is provided, we try to use x-www-form-urlencoded content
                                if (jsonContent.isEmpty()) {
                                    jsonContent = safeGet(content, "application/x-www-form-urlencoded", LinkedTreeMap.class);
                                }

                                if (jsonContent.isEmpty()) {
                                    jsonContent = safeGet(content, "*/*", LinkedTreeMap.class);
                                }

                                schema = safeGet(jsonContent, "schema", LinkedTreeMap.class);

                                if (!schema.isEmpty()) {
                                    recursiveTypeInference(schema);
                                }
                            }
                        })
        );
    }

    /**
     * Function that recursively searches for the missing 'type' field in parameter schemas. When a missing one is found,
     * if the parameter is compatible with an object or an array, the type is added to the parameter schema.
     * @param parameter the parameter for which the type should be inferred.
     */
    private static void recursiveTypeInference(Map<String, Object> parameter) {

        // Distinction between standard parameters and request/response body parameters
        Map<String, Object> targetMap = parameter.containsKey("schema") ?
                (Map<String, Object>) parameter.get("schema") :
                parameter;

        // If the type is missing, infer it
        if (!targetMap.containsKey("type")) {
            // Structured types
            if (targetMap.containsKey("properties") || targetMap.get("required") instanceof List) {
                targetMap.put("type", "object");
            } else if (targetMap.containsKey("items")) {
                targetMap.put("type", "array");
            }

            // Terminal types
            if (targetMap.containsKey("multipleOf") || targetMap.containsKey("maximum") ||
                    targetMap.containsKey("exclusiveMaximum") || targetMap.containsKey("minimum") ||
                    targetMap.containsKey("exclusiveMinimum")
            ) {
                targetMap.put("type", "number");
            }

            if (targetMap.containsKey("maxLength") || targetMap.containsKey("minLength") ||
                    targetMap.containsKey("pattern")
            ) {
                targetMap.put("type", "string");
            }

        }

        // Infer types also for combined schemas fields
        for (String field : new String[]{"oneOf", "allOf", "anyOf"}) {
            safeGet(targetMap, field, ArrayList.class).forEach(
                    s -> recursiveTypeInference((Map<String, Object>) s)
            );
        }

        if (targetMap.containsKey("not")) {
            recursiveTypeInference((Map<String, Object>) targetMap.get("not"));
        }

        // For structured types move downward in the structure to infer missing types
        switch (ParameterType.getTypeFromString((String) targetMap.get("type"))) {
            case OBJECT:
                Map<String, Map<String, Object>> properties = safeGet(targetMap, "properties", LinkedTreeMap.class);
                properties.values().forEach(OpenApiParserOldAmedeo::recursiveTypeInference);
            case ARRAY:
                Map<String, Object> items = safeGet(targetMap, "items", LinkedTreeMap.class);
                recursiveTypeInference(items);
                break;
        }
    }

    /**
     * Enriches the specification with an extension to keep track, through the additional field 'x-componentName', of
     * the name of the schemas before their normalization.
     */
    private static void addSchemasNames() {
        logger.debug("Enriching specification with schema names.");

        if (openApiMap.containsKey("components")) {
            Map<String, Object> components = (Map<String, Object>) openApiMap.get("components");

            Map<String, Map<String, Object>> schemas = safeGet(components, "schemas", LinkedTreeMap.class);

            for (Map.Entry<String, Map<String, Object>> schema : schemas.entrySet()) {
                schema.getValue().put("x-componentName", schema.getKey());
                schema.getValue().put("x-componentRef", "#/components/schemas/" + schema.getKey());
            }
        }
    }

    /**
     * Normalizes the 'required' attribute in request/response bodies. In fact, within schemas the 'required' field
     * is a list instead of a Boolean. Hence, we propagate the required values downwards in the structure
     */
    private static void unfoldRequiredAttributes() {
        Map<String, Object> paths = (Map<String, Object>) openApiMap.get("paths");

        // Iterate through path items and look for 'parameters'
        for (Map.Entry<String, Object> pathItemMap : paths.entrySet()) {

            if (pathItemMap.getKey().startsWith("x-")) {
                continue;
            }

            Map<String, Object> pathItem = (Map<String, Object>) pathItemMap.getValue();

            for (Map.Entry<String, Object> operation : pathItem.entrySet()) {

                if (!HttpMethod.isHttpMethod(operation.getKey())) {
                    continue;
                }

                Map<String, Object> operationMap = (Map<String, Object>) operation.getValue();

                // Check every item in the 'parameters' list
                List<Map<String, Object>> parameters = safeGet(operationMap, "parameters", ArrayList.class);
                parameters.forEach(parameter -> {
                    if (parameter.containsKey("schema")) {
                        recursiveUnfoldRequired((Map<String, Object>) parameter.get("schema"));
                    }
                });

                // Check for body parameters
                Map<String, Object> requestBody = safeGet(operationMap, "requestBody", LinkedTreeMap.class);
                Map<String, Object> content = safeGet(requestBody, "content", LinkedTreeMap.class);

                // At the moment we only support JSON and x-www-form-urlencoded
                Map<String, Object> jsonContent = safeGet(content, "application/json", LinkedTreeMap.class);

                // In case no JSON content is provided, we try to use x-www-form-urlencoded content
                if (jsonContent.isEmpty()) {
                    jsonContent = safeGet(content, "application/x-www-form-urlencoded", LinkedTreeMap.class);
                }

                if (jsonContent.isEmpty()) {
                    jsonContent = safeGet(content, "*/*", LinkedTreeMap.class);
                }

                Map<String, Object> schema = safeGet(jsonContent, "schema", LinkedTreeMap.class);

                if (!schema.isEmpty()) {
                    recursiveUnfoldRequired(schema);
                    // The required value is stored since it could be null. In this case, it should be considered 'false'
                    Boolean isRequired = (Boolean) requestBody.get("required");
                    requestBody.put("required", isRequired != null ? isRequired : false);
                }

                // Check for output parameters (response body)
                Map<String, Object> responses = safeGet(operationMap, "responses", LinkedTreeMap.class);

                for (Map.Entry<String, Object> responseMap : responses.entrySet()) {
                    Map<String, Object> response = (Map<String, Object>) responseMap.getValue();
                    content = safeGet(response, "content", LinkedTreeMap.class);

                    // At the moment we only support JSON and x-www-form-urlencoded
                    jsonContent = safeGet(content, "application/json", LinkedTreeMap.class);

                    // In case no JSON content is provided, we try to use x-www-form-urlencoded content
                    if (jsonContent.isEmpty()) {
                        jsonContent = safeGet(content, "application/x-www-form-urlencoded", LinkedTreeMap.class);
                    }

                    if (jsonContent.isEmpty()) {
                        jsonContent = safeGet(content, "*/*", LinkedTreeMap.class);
                    }

                    schema = safeGet(jsonContent, "schema", LinkedTreeMap.class);

                    if (!schema.isEmpty()) {
                        recursiveUnfoldRequired(schema);
                        //schema.put("required", true);
                    }
                }

            }

        }

    }

    /**
     * This function recursively scans JSON Parameters to normalize the required attribute. In object parameters, the
     * required field is provided as a list of required properties. The goal of the function is to bring these values
     * inside the parameters to reflect the structure of path/query/header parameters with a boolean required field.
     * @param map JSON schema of a parameter
     */
    private static void recursiveUnfoldRequired(Map<String, Object> map) {

        // Avoid crash for undefined schemas
        if (map == null) {
            return;
        }

        String type = safeGet(map, "type", String.class);

        // Induction step 1: objects contain required as a list. Arrays can contain objects as elements
        if (type.equals("object")) {
            List<String> required = safeGet(map, "required", ArrayList.class);
            map.remove("required");

            Map<String, Map<String, Object>> properties = safeGet(map, "properties", LinkedTreeMap.class);

            for (Map.Entry<String, Map<String, Object>> property : properties.entrySet()) {
                // Call the recursion first, avoiding overwriting the children required field
                recursiveUnfoldRequired(property.getValue());
                if (required.contains(property.getKey())) {
                    property.getValue().put("required", true);
                }
            }

        } else if (type.equals("array")) {
            recursiveUnfoldRequired((Map<String, Object>) map.get("items"));
        }

        // Induction step 2: if the parameter contains combined schemas, check for unsolved required
        List<Map<String, Object>> allOf = OpenApiParser.safeGet(map, "allOf", ArrayList.class);
        allOf.forEach(OpenApiParserOldAmedeo::recursiveUnfoldRequired);
        List<Map<String, Object>> anyOf = OpenApiParser.safeGet(map, "anyOf", ArrayList.class);
        anyOf.forEach(OpenApiParserOldAmedeo::recursiveUnfoldRequired);
        List<Map<String, Object>> oneOf = OpenApiParser.safeGet(map, "oneOf", ArrayList.class);
        oneOf.forEach(OpenApiParserOldAmedeo::recursiveUnfoldRequired);

        // Base step: simple parameter, so required can only be a boolean field

    }

    /**
     * This function unfolds shared parameters in paths. In fact, parameters that are common to every
     * path item defined within a path can be defined globally at path level. This function moves such values into each
     * path item.
     */
    private static void unfoldPathSharedParameters() {
        Map<String, Object> paths = (Map<String, Object>) openApiMap.get("paths");

        // Iterate through path items and look for 'parameters'
        for (Map.Entry<String, Object> pathItemMap : paths.entrySet()) {
            Map<String, Object> pathItem = (Map<String, Object>) pathItemMap.getValue();

            // Retrieve parameters if present
            List<Map<String, Object>> parameters = (List<Map<String, Object>>) pathItem.get("parameters");
            pathItem.remove("parameters");

            if (parameters == null) {
                continue;
            }

            Map<Pair<String, String>, Map<String, Object>> parametersMap = new HashMap<>();
            parameters.forEach(parameter ->
                    parametersMap.put(new Pair<>((String) parameter.get("name"), (String) parameter.get("in")), parameter)
            );

            // Copy all the parameters in the 'parameters' list (if exists) inside each operation
            // DO NOT OVERRIDE ALREADY DEFINED PARAMETERS!

            for (Map.Entry<String, Object> operationMap : pathItem.entrySet()) {
                // Parse iff the key is a supported HTTP method
                try {
                    HttpMethod.getMethod(operationMap.getKey());
                } catch (IllegalArgumentException e) {
                    continue;
                }

                Map<String, Object> operation = (Map<String, Object>) operationMap.getValue();
                List<Map<String, Object>> operationParameters = safeGet(operation, "parameters", ArrayList.class);

                if (operationParameters.isEmpty()) {
                    operation.put("parameters", operationParameters);
                }

                Set<Pair<String, String>> operationParameterSet = new HashSet<>();
                operationParameters.forEach(parameter ->
                        operationParameterSet.add(new Pair<>((String) parameter.get("name"), (String) parameter.get("in")))
                );

                // For each parameter, if not duplicate, add to operation parameters
                for (Map.Entry<Pair<String, String>, Map<String, Object>> parameter : parametersMap.entrySet()) {
                    if (!operationParameterSet.contains(parameter.getKey())) {
                        operationParameters.add(parameter.getValue());
                    }
                }

            }

        }

    }

    /**
     * This function expands the specification wrt to the '$ref' values, replacing references with their actual
     * content.
     */
    public static void expandOpenApiRefs() {

        // Resolve components first, since they are the targets of the refs
        if (openApiMap.containsKey("components")) {
            Map<String, Object> components = (Map<String, Object>) openApiMap.get("components");

            logger.debug("Solving components/schemas refs.");
            Map<String, Map<String, Object>> schemas = safeGet(components, "schemas", LinkedTreeMap.class);

            resolveSchemaRef(schemas);

            // Once resolved parameters schema refs, resolve schema items refs
            schemas.values().forEach(OpenApiParserOldAmedeo::resolvePropertyItemRef);

            // Parse responses
            logger.debug("Solving components/responses refs.");
            Map<String, Object> responses = safeGet(components, "responses", LinkedTreeMap.class);
            responses.values().forEach(response -> replaceContentRef((Map<String, Object>) response));

            // Parse parameters
            logger.debug("Solving components/parameters refs.");
            Map<String, Object> parameters = safeGet(components, "parameters", LinkedTreeMap.class);
            parameters.values().forEach(parameter -> replaceSchemaRef((Map<String, Object>) parameter));

            // Parse requestBodies
            logger.debug("Solving components/requestBodies refs.");
            Map<String, Object> bodies = safeGet(components, "requestBodies", LinkedTreeMap.class);
            bodies.values().forEach(body -> replaceContentRef((Map<String, Object>) body));

        }

        // Once components are solved, solve all refs inside pathItems
        recursiveReplaceRef((Map<String, Object>) openApiMap.get("paths"));

        logger.debug("Specification references solved.");
    }

    /**
     * Resolves schema refs using a queue, since every schema ref can potentially contain many other schema refs.
     * @param schemas Map with the schemas defined in 'components/schemas'
     */
    private static void resolveSchemaRef(Map<String, Map<String, Object>> schemas) {

        // Queue of the schemas to be solved.
        LinkedList<Pair<
                List<String>, // List of all the schemas that have already been solved along the path
                Map<String, Object> // Map containing the actual schema
                >> queue = new LinkedList<>();

        // Iterate through each schema and them to the queue to resolve refs
        for (Map<String, Object> schema : schemas.values()) {
            ArrayList<String> pathSolvedSchemas = new ArrayList<>(1);
            pathSolvedSchemas.add((String) schema.get("x-componentName")); // set as solved the root schema along the part starting from itself
            queue.addLast(new Pair<>(pathSolvedSchemas, schema)); // add to queue the path and its schema
        }

        // Resolve components refs
        while (!queue.isEmpty()) {
            Pair<List<String>, Map<String, Object>> top = queue.pollFirst();
            List<String> pathSolvedSchemas = top.getFirst();
            Map<String, Object> schema = top.getSecond();

            // Check whether the schema is only a ref
            if (schema.containsKey("$ref")) {
                Map<String, Object> solvedRef = getElementCloneByRef((String) schema.get("$ref"));
                String refSchemaName = (String) solvedRef.get("x-componentName");
                schema.remove("$ref"); // Remove ref field from specification

                // Check if the referred schema has already been solved along this path. If so, skip it (recursive ref)
                if (!pathSolvedSchemas.contains(refSchemaName)) {
                    schema.putAll(solvedRef); // Update the actual schema with the values in the referenced schema
                    ArrayList<String> extendedPathSolvedSchemas = new ArrayList<>(pathSolvedSchemas);
                    extendedPathSolvedSchemas.add(refSchemaName);
                    // Add the actual, resolved schema to the queue again, since it could contain other references in its subfields
                    queue.addLast(new Pair<>(extendedPathSolvedSchemas, schema));
                } else {
                    logger.warn("Recursive references found: {}, {}", pathSolvedSchemas, refSchemaName);
                }
            } else {
                // if combined schemas are present, solve them too
                List<Map<String, Object>> allOf = safeGet(schema, "allOf", ArrayList.class);
                allOf.forEach(element -> queue.addLast(new Pair<>(pathSolvedSchemas, element)));
                List<Map<String, Object>> oneOf = safeGet(schema, "oneOf", ArrayList.class);
                oneOf.forEach(element -> queue.addLast(new Pair<>(pathSolvedSchemas, element)));
                List<Map<String, Object>> anyOf = safeGet(schema, "anyOf", ArrayList.class);
                anyOf.forEach(element -> queue.addLast(new Pair<>(pathSolvedSchemas, element)));
                Map<String, Object> not = safeGet(schema, "not", LinkedTreeMap.class);
                if (!not.isEmpty()) {
                    queue.addLast(new Pair<>(pathSolvedSchemas, not));
                }

                // Check if the schema describes something structured (i.e., arrays or objects)
                if ("object".equals(schema.get("type")) || schema.containsKey("properties")) {
                    Map<String, Map<String, Object>> properties = safeGet(schema, "properties", LinkedTreeMap.class);
                    properties.forEach((key, value) -> queue.addLast(new Pair<>(pathSolvedSchemas, value)));
                } else if ("array".equals(schema.get("type")) || schema.containsKey("items")) {
                    Map<String, Object> items = safeGet(schema, "items", LinkedTreeMap.class);
                    queue.addLast(new Pair<>(pathSolvedSchemas, items));
                }
            }

            // If no ref is present and the schema describes something unstructured, then there can be no other refs in this path

        }
    }

    /**
     * Resolve refs for structured parameters (i.e., objects and arrays) recursively.
     * @param propertiesMap Map containing the description of the parameter.
     */
    private static void resolvePropertyItemRef(Map<String, Object> propertiesMap) {

        // Induction step 1: properties can contain referred items
        if (propertiesMap.containsKey("properties")) {
            ((Map<String, Object>) propertiesMap.get("properties")).values().forEach(
                    property -> resolvePropertyItemRef((Map<String, Object>) property)
            );
        }

        else if (propertiesMap.containsKey("items")) {
            Map<String, Object> itemValue = (Map<String, Object>) propertiesMap.get("items");
            if (itemValue.containsKey("$ref")) {
                propertiesMap.put("items", getElementCloneByRef((String) itemValue.get("$ref")));
                // Induction step 2: items can contain referred items
                resolvePropertyItemRef((Map<String, Object>) propertiesMap.get("items"));
            }

            // Base step
            // 'items' property does not contain refs

        }
    }

    /**
     * Replaces the reference to a schema with its actual value.
     * @param map Map that could potentially contain a schema reference.
     */
    private static void replaceSchemaRef(Map<String, Object> map) {
        if (map.containsKey("schema")) {
            Map<String, Object> schema = (Map<String, Object>) map.get("schema");

            if (schema.containsKey("$ref")) {
                Map<String, Object> solvedRef = getElementCloneByRef((String) schema.get("$ref"));
                map.put("schema", solvedRef);
            }
        }
    }

    /**
     * Replaces the reference to a content schema with its actual value.
     * @param map Content map that could potentially contain a schema reference.
     */
    private static void replaceContentRef(Map<String, Object> map) {
        Map<String, Object> content = safeGet(map, "content", LinkedTreeMap.class);

        for (Map.Entry<String, Object> mediaType : content.entrySet()) {
            Map<String, Object> mediaTypeMap = (Map<String, Object>) mediaType.getValue();

            replaceSchemaRef(mediaTypeMap);
        }
    }

    /**
     * Recursively replace references in a given map searching for map/list children.
     * @param map Map that could contain references to replace
     */
    private static void recursiveReplaceRef(Map<String, Object> map) {

        // Scan each child looking for a ref to solve
        for (Map.Entry<String, Object> child : map.entrySet()) {

            // Base step 3: the value is null
            if (child.getValue() == null) {
                return;
            }

            // Induction steps
            if (Map.class.isAssignableFrom(child.getValue().getClass())) {
                recursiveReplaceRef((Map<String, Object>) child.getValue());
            }
            else if (List.class.isAssignableFrom(child.getValue().getClass())) {
                recursiveReplaceRef((List<Object>) child.getValue());
            }

            // Base step 1: ref found
            else if (child.getKey().equals("$ref")) {
                Map<String, Object> referencedElement = getElementCloneByRef((String) child.getValue());
                map.clear();
                map.putAll(referencedElement);
                return; // When a ref is present, no other field should be used
            }

            // Base step 2: a simple value instead of a map/list is found. No action needed
        }
    }

    /**
     * Recursively replace references in a given list searching for map/list children.
     * @param list List that could contain references to replace
     */
    private static void recursiveReplaceRef(List<Object> list) {

        // Scan each child looking for a ref to solve
        for (Object child : list) {

            if (Map.class.isAssignableFrom(child.getClass())) {
                recursiveReplaceRef((Map<String, Object>) child);
            }
            else if (List.class.isAssignableFrom(child.getClass())) {
                recursiveReplaceRef((List<Object>) child);
            }
        }
    }

    /**
     * The function returns a deep clone of the component referenced by the input string.
     * The choice of the deep clone is to avoid unintentional modifications on the original object
     * @param ref path of the referenced resource
     * @return Deep clone of the referenced object
     */
    private static Map<String, Object> getElementCloneByRef(String ref) {
        Map<String, Object> map = openApiMap;
        String[] componentPath = ref.split("/");

        // Skip the first element, since it is a '#'
        for (int i = 1; i < componentPath.length; ++i) {
            map = (Map<String, Object>) map.get(componentPath[i]);
            if (map == null) {
                /*throw new InvalidOpenApiException("Reference to '" + ref + "' cannot be resolved since the element " +
                        "is missing in the specification.");*/
                logger.warn("Element {} not found. Cannot expand the reference.", ref);
                return new HashMap<>();
            }
        }

        // Copy object instead of put it directly to avoid unexpected behaviors
        // Used to avoid unintentional modifications to the map passed as parameter
        return ObjectHelper.deepCloneObject(map);
    }

    /**
     * This function returns the name of the object referenced by the string passed as parameter
     * @param ref path of the referenced resource
     * @return Name of the referenced resource
     */
    private static String getElementNameByRef(String ref) {
        String[] componentPath = ref.split("/");
        return componentPath[componentPath.length -1];
    }

    // TODO: move to ObjectHelper?
    // TODO: investigate if we can avoid taking a class as parameter
    /*
    Actually it is needed since T is always an abstract superclass or an interface (such as Set, List, ..).
    - We can avoid it using always Ts that are standard classes, but we could have to use the same classes of the map object
      (can be MAYBE avoided if T is a collection, since we could pass another collection to the constructor)
    - We can avoid it using the runtime type of the map object
    - ...?
     */
    public static <T, E extends T> E safeGet(Map<String, Object> map, String key, Class<E> type) throws CannotParseMapException {
        try {
            T res = (res = (T) map.get(key)) != null ? res : type.getDeclaredConstructor().newInstance();
            return type.cast(res);
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
            throw new CannotParseMapException();
        }
    }
}
